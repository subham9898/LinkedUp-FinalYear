// 34. this is like a manual way of creating tokens that will expire within 24 hrs 
// also this lets us or user join only 1 channel 

/*35. NOw we will automate this process that user can so that user can enter channel name and create their own room and also join others channels
        now we will install a python pakage that will allow us to generate all the tokens automaticlly
        in backend we make a view and a endpoint so whenever user goes in lobbly or enters a channel name , we are going to have a function in the view that utilise package
        and going to take our app id,app certificate , channel name entered by user . so when user enters achannel and joins a room a token will be generated for him
        so that an user can enter chnnel of his choice*/

//36. installing python package pip install agora-token-builder . if not working upgrade your pip --> Successfully installed agora-token-builder-1.0.0
//37. Now go to your base/views.py for next steps
// 55 making these three comment.
// const APP_ID = '2c67e9a895d04a318044724f6a4bc0d0'
// const CHANNEL = 'main'
// const TOKEN = '007eJxTYHjDs9fhz4OsM41ff2zb0KV+ek7Us7QjIkzTNlvV/Y0VKDBUYDBKNjNPtUy0sDRNMTBJNDa0MDAxMTcySTNLNElKNkgxKBAXTWsIZGRwsNvPzMgAgSA+C0NuYmYeAwMAzf0frg==' //generate token in 24 hr as of now
//generate token again in 24hrs

// 54. now that our view is implemented successfully we will check the token and uid generated by it
// const APP_ID = '2c67e9a895d04a318044724f6a4bc0d0'
// const CHANNEL = 'mynewsit'
// const TOKEN = '0062c67e9a895d04a318044724f6a4bc0d0IADe2uSExoGQ5Id6cwsGN7KBhhlp6VHTDKyIg5Q/UndZQAtCGHdBT8p1IgBowyQA1iUhZgQAAQDWJSFmAgDWJSFmAwDWJSFmBADWJSFm' 


// import AgoraManager from "../agora_manager/agora_manager.js";
// import AgoraRTC from "agora-rtc-sdk-ng";


//68.Now we will use our values stores in session
const APP_ID = '2c67e9a895d04a318044724f6a4bc0d0'
const CHANNEL = sessionStorage.getItem('room')
const TOKEN = sessionStorage.getItem('token') 
let UID = Number(sessionStorage.getItem('UID'))

// 80. getting name from session storage, but still we cant pass this name to all the other users
//  so we create a db that stores usename, roomname and userid. and we make a request to db before joining the user
//  we get all the values from database -->go to models.py
let NAME = sessionStorage.getItem('name')


const client = AgoraRTC.createClient({mode:'rtc',codec:'vp8'})

let localTracks = []

let remoteUsers = {}

let joinAndDisplayLocalStream = async () =>{

    //69. NOW WE WANT THE ROOM NAME TO BE DISPLAYED ON THE TOP OF ROOM
    document.getElementById('room-name').innerText = CHANNEL

    


    //7. when a user joins the channel or room , we will fire a function that will handle what to do with new user like creating his video and audio streams
        //'user-published is a event that happens when a user published his streams to the channel'
    client.on('user-published', handleUserJoined)

    //18. whenever user lefts , a new new event occurs that is 'user-left', so whenever this happens we remove the user from remoteUsers and also remove it from dom
    //what must happen when others left the channel not us
    client.on('user-left',handleUserLeft)


    // 57. now that we can generate our uid from view . we dont need it to fetch it from here . 
    //1.joining a chanel
    // UID = await client.join(APP_ID,CHANNEL,TOKEN,null) //null value i am pasing user id

    // 58. NOW WE WILL PASS OUR UID IN HERE JOIN function
    // await client.join(APP_ID,CHANNEL,TOKEN,UID)  // IT WORKING NOW



    //70. ALSO BEFORE DISPLAYING I WANT TO CHECK IF THERE IS A SESSION AVALAIBLE
    try{
        await client.join(APP_ID,CHANNEL,TOKEN,UID)
    }
    catch(error){
        //71. if there is no session storage we will redirect him to the lobby
        console.log(error)
        window.open('/lobby','self')
    }

    // 59. now we will go to our lobby.html and built an input for user to enter his channel name. get this channel name and pass it into our get_token view and generate token

    
    //2. getting the audio and video tracks now. this createMIcAndCam store audio and video tracks of client in an array. 0th value will be audio , next will be video
    localTracks = await AgoraRTC.createMicrophoneAndCameraTracks()

    //107. Now we will call createMember Function using await method, so that to stop the flow untill value arrives, otherwise it will display undefine or promise unresolved
    let member =  await createMember() // now memeber stores what is returned by createMember(name)
//    108. displaying name below member.name 
// 109. now we can see our name but others cant so we create another endpoint in the backend -->view.py

    //3.Now we are creating a video player to show all these. creating video players if anyone joins

    let player = ` <div class="video-container" id="user-conatiner-${UID}">
                                                                                        
                        <div class="username-wrapper"> <span class=" user-name"></span>${member.name}</div>
                        <div class="video-player" id="user-${UID}"></div>
                    </div>`

    //4. NOw inserting these video / player section into our html. in the room section

    document.getElementById('video-streams').insertAdjacentHTML("beforeend",player)
                let userNewDiv = document.createElement('div'); // Create a new <div> element
            let userNewParagraph = document.createElement('p'); // Create a new <p> element

            // Set the text content of the <p> element to the member's name
            userNewParagraph.textContent = member.name;

            userNewDiv.classList.add('my-div-class');
            userNewParagraph.classList.add('my-paragraph-class');


            // Append the <p> element to the <div> element
            userNewDiv.appendChild(userNewParagraph);

            // Append the new <div> element to the user-list-container
            document.getElementById('user-list-container').appendChild(userNewDiv);



    //5. Playing the video into the html tag using play method.

    localTracks[1].play(`user-${UID}`) // at index 1 of array "localtracks" video is stored . play Method requires an html tag to play video so UID is given

    //6. Now , we want everyone in the room to see our audio and video. so we publish it
        await client.publish([localTracks[0],localTracks[1]]) // localtracks[0] has our audio and [1] has our video. publish needs a array so we used []

}


//8. defining the function if a new use joined ---- user-published is just a event like oncllock,hover,etc
let handleUserJoined = async(user,mediaType) =>{

    //9. adding new users in remoteuser(it is an object in js that store remote users in room) as user_id as their key and user as hteir vlaue
    remoteUsers[user.uid] = user
    // 10. await is used to stop exceution until client is subscribed
                 //subscribe --> This method is used to subscribe to the audio and/or video streams of a remote user. 
                 //user: This parameter represents the remote user whose streams you want to subscribe to. It typically contains information about the remote user, including their unique identifier (UID).
                //mediaType: This parameter specifies the type of media streams to subscribe to. It can be either 'audio', 'video', or both, depending on the desired subscription.

    await client.subscribe(user,mediaType)


    //11. means it's checking if the remote user has published a video stream.
    if(mediaType === 'video'){
        // 12. getting the player with same id (if it exists)
        let player = document.getElementById(`user-container-${user.uid}`)

        //13.If the video player element already exists (player is not null), it removes the existing player element from the HTML document.
        //sometimes user refreshes the page so migth join 2 times , to avoid it if he exists remove it
        if(player!=null){
            player.remove()

        }

        // 119. calling the getMember to this user name from database,USING BELOW, 
        let member = await getMember(user)

       

        // document.getElementsByClassName
        // 14. if user doesnt exist or removed , we create a new user . The ID of this container is constructed using the UID of the remote user. 
         player = ` <div class="video-container" id="user-conatiner-${user.uid}">
                        <div class="username-wrapper"> <span class=" user-name"></span>${member.name}</div> 
                        <div class="video-player" id="user-${user.uid}"></div>
                    </div>`

        //15. NOw inserting these video / player section into our html. in the room section . before end means as top

        document.getElementById('video-streams').insertAdjacentHTML("beforeend",player)

        let userNewDiv = document.createElement('div'); // Create a new <div> element
            let userNewParagraph = document.createElement('p'); // Create a new <p> element

            // Set the text content of the <p> element to the member's name
            userNewParagraph.textContent = member.name;

            userNewDiv.classList.add('my-div-class');
            userNewParagraph.classList.add('my-paragraph-class');
            // Append the <p> element to the <div> element
            userNewDiv.appendChild(userNewParagraph);

            // Append the new <div> element to the user-list-container
            document.getElementById('user-list-container').appendChild(userNewDiv);
               

        // 16. It plays the video stream of the remote user in the newly created video player element.
        user.videoTrack.play(`user-${user.uid}`)

    }

    // 17  it's checking if the remote user has published an audio stream. then play audio
    if(mediaType === 'audio'){
        user.audioTrack.play()
    }
    // updateUsersList()
}

//19. creating method that will help in removing users from DOM and remote users whenever user lefts
// what must happen when others left the channel not us

let handleUserLeft = async(user) =>{
    //20. removing user from remoteUsers object
    delete remoteUsers[user.uid]

    //21. Now removing it from DOM by finding it using its id
    document.getElementById(`user-conatiner-${user.uid}`).remove()
    let userNameElements = document.querySelectorAll('#user-list-container div p');

    // Loop through the p elements and remove the user's name if found
    userNameElements.forEach((userNameElement) => {
        if (userNameElement.textContent === user.name) {
            console.log(userNameElement.textContent)
            userNameElement.parentElement.remove(); // Remove the parent div element
        }
    });
    
}


//22. function that remvoe us from meeting

let leaveAndRemoveLocalStream = async() =>{
    //23. now we will go through the localtracks which stores our audio ans video. localTracks is an array where 0 index stores audio and 1 stores our video
    for(let i = 0;localTracks.length>i;i++){

        // 23. we stop tthe track but it can be opened
        localTracks[i].stop()

        // 24 . closes official closes out our track
        localTracks[i].close()
    }

    //25. now after closing our audio and video tracks . we leave the channel
    await client.leave();

    // 128. deleting from database
    deleteMember()

    // 26. now we will send the user to home page or say the lobby
    window.open('/lobby','_self')
}

//28. camera toogle button. if it open close it or if it is close open it
let toggleCamerabutton = async(e) =>{

    //29. if camera is off
    if(localTracks[1].muted){
        //30. video is stored on index 1
        await localTracks[1].setMuted(false)

        //31.Depending on the camera state, the function updates the background color of the clicked element (e.target)
        e.target.style.backgroundColor = "#fff"

    }
    // 32. the else part
    else{
        await localTracks[1].setMuted(true)
        e.target.style.backgroundColor = "#ff0000"

    }
}

//33. audio toggle button all things are same as video toogle but audio tracks are stored on localstreams[0] index
let toggleAudiobutton = async(e) =>{
    if(localTracks[0].muted){
        await localTracks[0].setMuted(false)
        e.target.style.backgroundColor = "#fff"

    }

    else{
        await localTracks[0].setMuted(true)
        e.target.style.backgroundColor = "#ff0000"

    }
}


// 103. function to send data to crete a user in backend (to show the name)
let createMember = async() =>{
    // 104. The fetch function is used to send a request to a server and it returns a Promise 
let response = await fetch('/create_member',{
    method:'POST',
    headers:{
        'Content-Type':'application/json'
    },
    body:JSON.stringify({'name':NAME,'room_name':CHANNEL,'UID':UID}) //sending this data to backend. createmember view
    

    })

    // 105. things goy by fetch is into response. so we parse it and return it
    let member = await response.json() //this response contains user name sent by createMember view from views.py
    return member
    // 106. now first we call this into joinAndDisplayLocalStream so that we can see our name , then we call it for everyone
}


// adding users to list
let users = [];



// 115. function to get others name from database
// to get the remote user id , pass user as parameter
let getMember = async(user) =>{
//116. sending data to backend view via url . note that UID is our uid(local user) but user.id is remote . so we must not pass UID
    let response = await fetch(`/get_member?UID=${user.uid}&room_name=${CHANNEL}`)
    // 117. pasing the data . must use await 
    let member = await response.json()

    users.push(member); // Add the member to the users array
    return member
    // 118. Now we will call this function inside handleremoteuser. so that whenver new user joins we got the name

}



//120. NOW WE WANT TO DELETE USER FROM DATABASE THE MOMENTS HE LEAVES THE ROOM --go to views.py
let deleteMember = async() =>{
    // 124. The fetch function is used to send a request to a server and it returns a Promise 
let response = await fetch('/delete_member',{
    method:'POST',
    headers:{
        'Content-Type':'application/json'
    },
    body:JSON.stringify({'name':NAME,'room_name':CHANNEL,'UID':UID}) //sending this data to backend. deletemember view
    

    })

    // 125. things goy by fetch is into response. so we parse it and return it
    let member = await response.json() //this response contains message from backend(e.g.,"user deleted") sent by createMember view from views.py
//    127. Now we will call this method whenver we leave or closes the stream or someone else leave
// 127.1--> whenrver we leave into leave and remove local Stream
// 127.2 --> whenever we close the window, we create a event listener for this below
    }
   
    // let updateUsersList = () => {
    //     let userListContainer = document.getElementsByClassName('user-list-container'); // Assuming you have a container with id 'user-list'
    //     userListContainer.innerHTML = ''; // Clear the previous content
    //     users.forEach(user => {
    //         userListContainer.innerHTML += `<div class="user">${user.name}</div>`; // Add each user to the HTML
    //     });
    // };

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        // CHAT SDK INTEGRATION

        // let initiateRTM = async() =>{
        //     let client = await AgoraRTM.createInstance(APP_ID)
        //     await client.login({UID,TOKEN})

        //     const channel = await client.createChannel(CHANNEL)
        //     await channel.join()
        //     let form = document.getElementById('formchat')


        //     form.addEventListener('submit',async(e) =>{
        //         e.preventDefault()
        //         let message = e.target.message.value
        //         await channel.sendMessage({text:message,type:'text'})
        //         form.reset()

        //         handleMessage({text:message})
        //     })

        //     channel.on('ChannelMessage',(message,peerId) =>{

        //         handleMessage(message)
        //     })
        // } 

        // let handleMessage = async(message) =>{
        //     let messages = document.getElementById('messageschat')
        //     let messageElement = `<p>${message.text}</p>`
        //     messages.insertAdjacentHTML('beforeend',messageElement)
        // }

        // initiateRTM()








// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   







//calling the first method
joinAndDisplayLocalStream()

// Example event handler for when a new member joins the room



window.addEventListener('beforeunload',deleteMember)
//27.getting the leave button and applying leaveAndRemoveLocalStream as event listener

document.getElementById('leave-btn').addEventListener('click',leaveAndRemoveLocalStream)

//28.0 video toogle event
document.getElementById('video-btn').addEventListener('click',toggleCamerabutton)

//33.0 audio toogle button
document.getElementById('mic-btn').addEventListener('click',toggleAudiobutton)


// // screen sharing-------------------------------------------------------------------------------------------
// const startScreenShare = async (channelParameters, screenPlayerContainer, localPlayerContainer) => {
//     // Create a screen track for screen sharing.
//     channelParameters.screenTrack = await AgoraRTC.createScreenVideoTrack();

//     // Unpublish and close the local video track.
//     await agoraManager.getAgoraEngine().unpublish([channelParameters.localVideoTrack]);
//     channelParameters.localVideoTrack.close();

//     // Publish the screen track.
//     await agoraManager.getAgoraEngine().publish([channelParameters.screenTrack]);

//     // Play the screen track in the screen player container.
//     channelParameters.screenTrack.play(screenPlayerContainer);
// };

// const stopScreenShare = async (channelParameters, localPlayerContainer) => {
//     // Unpublish and close the screen track.
//     await agoraManager.getAgoraEngine().unpublish([channelParameters.screenTrack]);
//     channelParameters.screenTrack.close();

//     // Create a new local video track.
//     channelParameters.localVideoTrack = await AgoraRTC.createCameraVideoTrack();

//     // Publish the local video track.
//     await agoraManager.getAgoraEngine().publish([channelParameters.localVideoTrack]);

//     // Play the local video track in the local player container.
//     channelParameters.localVideoTrack.play(localPlayerContainer);
// };

// // Get references to the player containers
// const screenPlayerContainer = document.getElementById('screenPlayerContainer');
// const localPlayerContainer = document.getElementById('localPlayerContainer');

// // Attach event listeners to the buttons
// document.getElementById('startScreenShareBtn').addEventListener('click', () => startScreenShare(channelParameters, screenPlayerContainer, localPlayerContainer));
// document.getElementById('stopScreenShareBtn').addEventListener('click', () => stopScreenShare(channelParameters, localPlayerContainer));
